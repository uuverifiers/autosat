// -*- Java -*- This Cup file was machine-generated by BNFC
package grammar;

parser code {:
  public grammar.Absyn.ModelRule pModelRule() throws Exception
  {
	java_cup.runtime.Symbol res = parse();
	return (grammar.Absyn.ModelRule) res.value;
  }

public <B,A extends java.util.LinkedList<? super B>> A cons_(B x, A xs) { xs.addFirst(x); return xs; }

public void syntax_error(java_cup.runtime.Symbol cur_token)
{
	report_error("Syntax Error, trying to recover and continue parse...", cur_token);
}

public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) throws java.lang.Exception
{
	throw new Exception("Unrecoverable Syntax Error");
}

:}

nonterminal grammar.Absyn.ModelRule ModelRule;
nonterminal grammar.Absyn.TransducerRule TransducerRule;
nonterminal grammar.Absyn.InitRule InitRule;
nonterminal grammar.Absyn.TransitionRule TransitionRule;
nonterminal grammar.Absyn.AcceptingRule AcceptingRule;
nonterminal grammar.Absyn.AutomatonRule AutomatonRule;
nonterminal grammar.Absyn.AutomataInitRule AutomataInitRule;
nonterminal grammar.Absyn.AutomataTransitionRule AutomataTransitionRule;
nonterminal grammar.Absyn.AutomataAcceptingsRule AutomataAcceptingsRule;
nonterminal grammar.Absyn.VerifierOption VerifierOption;
nonterminal grammar.Absyn.ListVerifierOption ListVerifierOption;
nonterminal grammar.Absyn.SymmetryOption SymmetryOption;
nonterminal grammar.Absyn.ListSymmetryOption ListSymmetryOption;
nonterminal grammar.Absyn.MaybeClosed MaybeClosed;
nonterminal grammar.Absyn.Name Name;
nonterminal grammar.Absyn.ListTransitionRule ListTransitionRule;
nonterminal grammar.Absyn.ListAutomataTransitionRule ListAutomataTransitionRule;
nonterminal grammar.Absyn.ListName ListName;

terminal _SYMB_0;    //   {
terminal _SYMB_1;    //   }
terminal _SYMB_2;    //   :
terminal _SYMB_3;    //   ;
terminal _SYMB_4;    //   ->
terminal _SYMB_5;    //   /
terminal _SYMB_6;    //   ..
terminal _SYMB_7;    //   ,
terminal _SYMB_8;    //   F
terminal _SYMB_9;    //   I0
terminal _SYMB_10;    //   P1
terminal _SYMB_11;    //   P2
terminal _SYMB_12;    //   accepting
terminal _SYMB_13;    //   automatonStateGuessing
terminal _SYMB_14;    //   closedUnderTransitions
terminal _SYMB_15;    //   explicitChecksUntilLength
terminal _SYMB_16;    //   init
terminal _SYMB_17;    //   initAutomatonStateGuessing
terminal _SYMB_18;    //   logLevel
terminal _SYMB_19;    //   loop
terminal _SYMB_20;    //   monolithicWitness
terminal _SYMB_21;    //   noPrecomputedInvariant
terminal _SYMB_22;    //   parallel
terminal _SYMB_23;    //   rotation
terminal _SYMB_24;    //   rotationStartingWith
terminal _SYMB_25;    //   symmetries
terminal _SYMB_26;    //   transducerStateGuessing
terminal _SYMB_27;    //   useRankingFunctions







terminal String LabelIdent;
terminal String MyInteger;


start with ModelRule;


ModelRule ::= _SYMB_9 AutomatonRule:p_2 MaybeClosed:p_3 _SYMB_8 AutomatonRule:p_5 _SYMB_10 TransducerRule:p_7 _SYMB_11 TransducerRule:p_9 ListVerifierOption:p_10  {: RESULT = new grammar.Absyn.Model(p_2,p_3,p_5,p_7,p_9,p_10); :} 
;
TransducerRule ::= _SYMB_0 InitRule:p_2 ListTransitionRule:p_3 AcceptingRule:p_4 _SYMB_1  {: RESULT = new grammar.Absyn.Transducer(p_2,p_3,p_4); :} 
;
InitRule ::= _SYMB_16 _SYMB_2 Name:p_3 _SYMB_3  {: RESULT = new grammar.Absyn.TransducerInitialState(p_3); :} 
;
TransitionRule ::= Name:p_1 _SYMB_4 Name:p_3 Name:p_4 _SYMB_5 Name:p_6  {: RESULT = new grammar.Absyn.FulTransition(p_1,p_3,p_4,p_6); :} 
  | Name:p_1 _SYMB_4 Name:p_3  {: RESULT = new grammar.Absyn.EmptyTransition(p_1,p_3); :}
  | _SYMB_19 _SYMB_2 ListName:p_3  {: RESULT = new grammar.Absyn.LoopingTransition(p_3); :}
;
AcceptingRule ::= _SYMB_12 _SYMB_2 ListName:p_3 _SYMB_3  {: RESULT = new grammar.Absyn.TransducerAccepting(p_3); :} 
;
AutomatonRule ::= _SYMB_0 AutomataInitRule:p_2 ListAutomataTransitionRule:p_3 AutomataAcceptingsRule:p_4 _SYMB_1  {: RESULT = new grammar.Absyn.Automaton(p_2,p_3,p_4); :} 
;
AutomataInitRule ::= _SYMB_16 _SYMB_2 Name:p_3 _SYMB_3  {: RESULT = new grammar.Absyn.AutomataInitialState(p_3); :} 
;
AutomataTransitionRule ::= Name:p_1 _SYMB_4 Name:p_3 Name:p_4  {: RESULT = new grammar.Absyn.AutomataTransition(p_1,p_3,p_4); :} 
  | Name:p_1 _SYMB_4 Name:p_3  {: RESULT = new grammar.Absyn.AutomataEmptyTransition(p_1,p_3); :}
;
AutomataAcceptingsRule ::= _SYMB_12 _SYMB_2 ListName:p_3 _SYMB_3  {: RESULT = new grammar.Absyn.AutomataAcceptings(p_3); :} 
;
VerifierOption ::= _SYMB_26 _SYMB_2 MyInteger:p_3 _SYMB_6 MyInteger:p_5  {: RESULT = new grammar.Absyn.NumOfStatesTransducerGuess(p_3,p_5); :} 
  | _SYMB_13 _SYMB_2 MyInteger:p_3 _SYMB_6 MyInteger:p_5  {: RESULT = new grammar.Absyn.NumOfStatesAutomatonGuess(p_3,p_5); :}
  | _SYMB_17 _SYMB_2 MyInteger:p_3 _SYMB_6 MyInteger:p_5  {: RESULT = new grammar.Absyn.NumOfInitStatesAutomatonGuess(p_3,p_5); :}
  | _SYMB_25 _SYMB_2 ListSymmetryOption:p_3  {: RESULT = new grammar.Absyn.SymmetryOptions(p_3); :}
  | _SYMB_15 _SYMB_2 MyInteger:p_3  {: RESULT = new grammar.Absyn.ExplicitChecks(p_3); :}
  | _SYMB_27  {: RESULT = new grammar.Absyn.UseRankingFunctions(); :}
  | _SYMB_20  {: RESULT = new grammar.Absyn.MonolithicWitness(); :}
  | _SYMB_21  {: RESULT = new grammar.Absyn.NoPrecomputedInv(); :}
  | _SYMB_18 _SYMB_2 MyInteger:p_3  {: RESULT = new grammar.Absyn.LogLevel(p_3); :}
  | _SYMB_22 _SYMB_2 MyInteger:p_3  {: RESULT = new grammar.Absyn.ParLevel(p_3); :}
;
ListVerifierOption ::=  /* empty */  {: RESULT = new grammar.Absyn.ListVerifierOption(); :} 
  | ListVerifierOption:p_1 VerifierOption:p_2 _SYMB_3  {: RESULT = p_1; p_1.addLast(p_2); :}
;
SymmetryOption ::= _SYMB_23  {: RESULT = new grammar.Absyn.RotationSymmetry(); :} 
  | _SYMB_24 _SYMB_0 ListName:p_3 _SYMB_1  {: RESULT = new grammar.Absyn.RotationWithSymmetry(p_3); :}
;
ListSymmetryOption ::=  /* empty */  {: RESULT = new grammar.Absyn.ListSymmetryOption(); :} 
  | SymmetryOption:p_1  {: RESULT = new grammar.Absyn.ListSymmetryOption(); RESULT.addLast(p_1); :}
  | SymmetryOption:p_1 _SYMB_7 ListSymmetryOption:p_3  {: RESULT = p_3; p_3.addFirst(p_1); :}
;
MaybeClosed ::= _SYMB_14 _SYMB_3  {: RESULT = new grammar.Absyn.ClosedInit(); :} 
  |  /* empty */  {: RESULT = new grammar.Absyn.NotClosedInit(); :}
;
Name ::= MyInteger:p_1  {: RESULT = new grammar.Absyn.NumberName(p_1); :} 
  | LabelIdent:p_1  {: RESULT = new grammar.Absyn.LiteralName(p_1); :}
;
ListTransitionRule ::=  /* empty */  {: RESULT = new grammar.Absyn.ListTransitionRule(); :} 
  | TransitionRule:p_1  {: RESULT = new grammar.Absyn.ListTransitionRule(); RESULT.addLast(p_1); :}
  | TransitionRule:p_1 _SYMB_3 ListTransitionRule:p_3  {: RESULT = p_3; p_3.addFirst(p_1); :}
;
ListAutomataTransitionRule ::=  /* empty */  {: RESULT = new grammar.Absyn.ListAutomataTransitionRule(); :} 
  | AutomataTransitionRule:p_1  {: RESULT = new grammar.Absyn.ListAutomataTransitionRule(); RESULT.addLast(p_1); :}
  | AutomataTransitionRule:p_1 _SYMB_3 ListAutomataTransitionRule:p_3  {: RESULT = p_3; p_3.addFirst(p_1); :}
;
ListName ::=  /* empty */  {: RESULT = new grammar.Absyn.ListName(); :} 
  | Name:p_1  {: RESULT = new grammar.Absyn.ListName(); RESULT.addLast(p_1); :}
  | Name:p_1 _SYMB_7 ListName:p_3  {: RESULT = p_3; p_3.addFirst(p_1); :}
;

